// Code generated by Arduino IoT Cloud, DO NOT EDIT.

#include <ArduinoIoTCloud.h>
#include <Arduino_ConnectionHandler.h>
#include "DFRobot_EnvironmentalSensor.h"
#include <DFRobot_SGP40.h>

DFRobot_EnvironmentalSensor environment(/*addr = */SEN050X_DEFAULT_DEVICE_ADDRESS, /*pWire = */&Wire);
DFRobot_SGP40    mySgp40(&Wire);

const char DEVICE_LOGIN_NAME[]  = "c1e26219-e50e-4df4-971f-2aa85de08841";

const char SSID[]               = SECRET_SSID;    // Network SSID (name)
const char PASS[]               = SECRET_OPTIONAL_PASS;    // Network password (use for WPA, or use as key for WEP)
const char DEVICE_KEY[]  = SECRET_DEVICE_KEY;    // Secret device password


float temperature = 00.00;
float humidity = 00.00;
String air = "NA";
String dust = "NA";
int noise = 0;
float light = 00.00;
bool cooling, heating;
String status = "";

int cooler = D10;
int heater = D11;
int exhaust = D12;
int lights = D13;

int HighTemp_rLED = D2;
int LowTemp_bLED = D3;
int airQ_gLED = D5;
int HighNoise_yLED = D6;

int SoundSensor =  A3;
int buzzer = D9;

int DustPin = D7;
unsigned long duration;
unsigned long starttime;
unsigned long sampletime_ms = 1000;
unsigned long lowpulseoccupancy = 0;
float ratio = 0;
float concentration = 0;

const int sampleWindow = 50;                              // Sample window width in mS (50 mS = 20Hz)
unsigned int sample;
 

void init_GPIO(){
  pinMode(SoundSensor, INPUT);

  pinMode(buzzer, OUTPUT);

  pinMode(cooler, OUTPUT);
  pinMode(heater, OUTPUT);
  pinMode(exhaust, OUTPUT);
  pinMode(lights, OUTPUT);

  pinMode(HighTemp_rLED, OUTPUT);
  pinMode(LowTemp_bLED, OUTPUT);
  pinMode(airQ_gLED, OUTPUT);
  pinMode(HighNoise_yLED, OUTPUT);

  digitalWrite(buzzer, HIGH);

  digitalWrite(cooler, LOW);
  digitalWrite(heater, LOW);
  digitalWrite(exhaust, LOW);
  digitalWrite(lights, LOW);

  digitalWrite(HighTemp_rLED, LOW);
  digitalWrite(LowTemp_bLED, LOW);
  digitalWrite(airQ_gLED, LOW);
  digitalWrite(HighNoise_yLED, LOW);

  analogReadResolution(10);

}

void shortBeep(){
  digitalWrite(buzzer, LOW);
  delay(500);
  digitalWrite(buzzer, HIGH);
}

void LongBeep(){
  digitalWrite(buzzer, LOW);
  delay(1000);
  digitalWrite(buzzer, HIGH);  
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max)
{
      return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void endNextionCommand()
{
  Serial.write(0xff);
  Serial.write(0xff);
  Serial.write(0xff);
}

void sendTemperatureToNextion()
{
  String command = "temperature.txt=\""+String(temperature,2)+"\"";
  Serial.print(command);
  endNextionCommand();
}


void sendHumidityToNextion()
{
  String command = "humidity.txt=\""+String(humidity,2)+"\"";
  Serial.print(command);
  endNextionCommand();
}

void sendAirToNextion()
{
  String command = "air.txt=\""+air+"\"";
  Serial.print(command);
  endNextionCommand();
}


void sendDustToNextion()
{
  String command = "dust.txt=\""+dust+"\"";
  Serial.print(command);
  endNextionCommand();
}

void sendNoiseToNextion()
{
  String command = "noise.txt=\""+String(noise)+"\"";
  Serial.print(command);
  endNextionCommand();
}

void sendLightToNextion()
{
  String command = "light.txt=\""+String(light,2)+"\"";
  Serial.print(command);
  endNextionCommand();
}

void init_EnvSensor(){
  Serial.println("Initilizing Env-sensor...");
  while(environment.begin() != 0){
  Serial.println(" Sensor initialize failed!!");
  delay(1000);
  }
  Serial.println(" Sensor  initialize success!!");
  delay(500);
}

void init_AirSensor(){
  Serial.println("Initilizing AirQ-sensor...");
  Serial.println("sgp40 is starting, the reading can be taken after 10 seconds...");
  /*
   * The preheating time of the sensor is 10s.
   * duration:Initialize the wait time. Unit: millisecond. Suggestion: duration > = 10000 ms
   */
  while(mySgp40.begin(/*duration = */10000) !=true){
    Serial.println("failed to init chip, please check if the chip connection is fine");
    delay(1000);
  }
  Serial.println("----------------------------------------------");
  Serial.println("sgp40 initialized successfully!");
  Serial.println("----------------------------------------------");
  delay(500);
}

void getAirQ(){
  mySgp40.setRhT(humidity, temperature );
  uint16_t index = mySgp40.getVoclndex();

  if(index>=0 && index<=100){
    air = "Excellent";
  } else if(index>=100 && index<=200){
    air = "Good";
  }else if(index>=200 && index<=300){
    air = "Lightly Polluted";
  }else if(index>=300 && index<=400){
    air = "Moderately Polluted";
  }else if(index>=400 && index<=500){
    air = "Heavily Polluted";
  }
}

void calculate_Noise(){
   unsigned long startMillis= millis();                   // Start of sample window
   float peakToPeak = 0;                                  // peak-to-peak level
 
   unsigned int signalMax = 0;                            //minimum value
   unsigned int signalMin = 1024;                         //maximum value
 
                                                          // collect data for 50 mS
   while (millis() - startMillis < sampleWindow)
   {
      sample = analogRead(SoundSensor);                    //get reading from microphone
      if (sample < 1024)                                  // toss out spurious readings
      {
         if (sample > signalMax)
         {
            signalMax = sample;                           // save just the max levels
         }
         else if (sample < signalMin)
         {
            signalMin = sample;                           // save just the min levels
         }
      }
   }
 
   peakToPeak = signalMax - signalMin;                    // max - min = peak-peak amplitude
   noise = map(peakToPeak,20,900,10,55);               //calibrate for deciBels
}

void calculate_dust(){
  duration = pulseIn(DustPin, LOW);
  lowpulseoccupancy = lowpulseoccupancy+duration;
 
  if ((millis()-starttime) > sampletime_ms)
  {
    ratio = lowpulseoccupancy/(sampletime_ms*10.0);  // Integer percentage 0=>100
    concentration = 1.1*pow(ratio,3)-3.8*pow(ratio,2)+520*ratio+0.62; // using spec sheet curve
    lowpulseoccupancy = 0;
 
  if (concentration < 1000) {
    dust = "Clean";
  }

  if (concentration > 1000 && concentration < 10000) {
    dust = "Good";
  }

    if (concentration > 10000 && concentration < 20000) {
    dust = "Acceptable"; 
  }

  if (concentration > 20000 && concentration < 50000) {
    LongBeep();
    dust = "Heavy";
    exhaust = HIGH;
  }

  if (concentration > 50000 ) {
    LongBeep();
    dust = "Hazard";
    exhaust = HIGH;
  } 

  starttime = millis();
  }  
}

void calculate_status(){
  //tempStatus = tempStatus + "\nclassroom Environment : " + "\n" + "Air Quality = " + air + "\n" + "dust = " + dust + "\n";
  if (air == "Excellent") {
    status = "Air Quality : Excellent";
  } else if(air == "Good"){
    status = "Air Quality : Good";
  } else {
    status = "Air Quality : Polluted, Taking Initilizing measures";
  }
}

void getReadings(){
  temperature = environment.getTemperature(TEMP_C);

  if(temperature>= 27){
    shortBeep();
    HighTemp_rLED = HIGH;
    cooling = HIGH;
    cooler = HIGH;
  } else if(temperature<= 18){
    shortBeep();
    LowTemp_bLED = HIGH;
    heating = HIGH;
    heater = HIGH;
  }else {
    HighTemp_rLED = LOW;
    LowTemp_bLED = LOW;
    cooling = LOW;
    cooler = LOW;
    heating = LOW;
    heater = LOW;
  }

  humidity = environment.getHumidity();
  float Tlight = environment.getLuminousIntensity();
  light = mapfloat(Tlight, 0.0, 250.00, 0.0, 100.00);
  getAirQ();
  calculate_dust();
  calculate_Noise();
  calculate_status();
}


void initProperties(){

  ArduinoCloud.setBoardId(DEVICE_LOGIN_NAME);
  ArduinoCloud.setSecretDeviceKey(DEVICE_KEY);
  ArduinoCloud.addProperty(status, READ, ON_CHANGE, NULL);
  ArduinoCloud.addProperty(temperature, READ, 10 * SECONDS, NULL);
  ArduinoCloud.addProperty(noise, READ, 10 * SECONDS, NULL);
  ArduinoCloud.addProperty(cooling, READ, ON_CHANGE, NULL);
  ArduinoCloud.addProperty(heating, READ, ON_CHANGE, NULL);

}

WiFiConnectionHandler ArduinoIoTPreferredConnection(SSID, PASS);
